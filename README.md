# Frequency Domain Perfectly Matched Layer (FDPML)

## Introduction

FDPML is a computational method to simulate heat transport through nanostructured materials. The method converts atomistic equations of motion for every atom inside a simulation domain to a set of linear algebraic equations. The equations can then be solved using iterative solvers. The model is efficient as it stores the matrices in sparse format (COO), while also being able to be deployed across multiple cluster node.

For a more detailed mathematical description of the model please refer  
`kakodkar et. al. Journal of Applied Physics 118, 094301 (2015)`

## Installation

### Dependencies

1. MPI
1. openmpi FORTRAN90 Compiler
1. IntelMKL

Clone this repository using `git clone git@github.com:jpfeser/FDPML.git`

Install using Makefile : `make all`

Upon installation execultables will be created in `\bin` folder

## Usage

### Overview

The method can be used to obtain 2 properties intrinsic to heat transport through nanostructured materials.

1. Transmission coefficient across interfaces- Please refer [here](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.95.125434)
2. Scattering Cross-section due to nanoparticles- Please refer [here](https://aip.scitation.org/doi/abs/10.1063/1.5031757)

Input parameters for simulations are specified through input cards described below

All quantities whose dimensions are not explicitly specified are in RYDBERG ATOMIC UNITS. Charge is "number" charge (i.e. not multiplied by e); potentials are in energy units (i.e. they are multiplied by e).

Structure of the input data:

	&filenames
		...
	/
	&system
		...
	/
	&postprocessing
		...
	/
	&plotting
		...
	/

### Detailed discription

Input cards:

1. filenames
	* **flfrc1**-*1st Quantum Espresso force constant file, usually of the matrix material or rhs material (see gendomain repo). NOT IN XML FORMAT*
	* **flfrc2**-*2nd Quantum Espresso force constant file, usually of an embedded material or lhs material (see gendomain repo). NOT IN XML FORMAT*
	* **mass_input** -*logical, if true masses are calculated with atomic resolution else masses are calculated based on supercell*
	* **mass_file** -*mass domain file generated by gendomain.f90*
	* **domain_file** -*domain specification generated by gendomain.f90*

2. system
	* **simulation_type** = *'interface' or 'nanoparticle'*
	* **PD** = *size of the primary domain, should be same as the one generated gendomain.f90*
	* **LPML** = *length of PML. Ignored if PML calculation is auto*
	* **periodic** = *logical, if true applied periodic boundaries in x and y direction*
	* **crystal_coordinates** = *logical (default: .false.), if true work in crystal coordinates*
	* **asr** = *str (default 'simple'), acoustic sum rule. Refer QE documentation*
	* **wavetype** = *'half' or 'full' to specify type of incident wave*
	* **q** = *wavevector, ignored if mp = .true.*
	* **mode** = *polarization (integer, from lowest to highest frequency)*
	* **sigmamax** = *maximum non-dimensional damping coefficient (same sig*(k*LPML)/omega)*
	* **expense_estimate** = *logical (default: .false.) if .true. this run only calculates the memory requirements for the set of input parameters*
3. qlists
	* **q_from_file**: *logical (default: .false.), if .true. then simulated multiple incident q points at one time*
	* **q_file**: name of file containing q-points to use if q_from_file=.true., ignore if q_from_file=.false.(default)*
4. solver
	* **tol**: real (default: 1E-6), relative tolerance for when iterative solver should stop
	* **maxit**: int (default: 10000), max number of iterations before stopping iterative solver
5. restartoptions
	* **iterpause** *int (default: 10), how often to store checkpoint.*
	* **tmp_dir**:  *string, directory to store/look for  checkpoint file*
	* **restart**:  *logical (default: .false.), if .true. then starts from checkpoint file in tmp_dir*
6. postprocessing
	* **calc_TC** = *logical (default, .false.), calculate transmission coefficient (for interface problems)*
	* **scattered_energy**: *logical (default, .false.), calculate total scattered energy*
	* **scattering_Xsec**: *logical (default, .false.), calculate total scattered energy per incident intensity*
7. plotting
	* **plot_K**  = *logical (default, .false.), plot variation of K vector on TD(3)/2 plane*
	* **plot_uinc** = *logical (default, .false.), plot incident wave*
	* **plot_uscat** = *logical (default, .false.), plot scattered wave*
	* **plot_sig** = *logical (default, .false.), plot variation of damping coefficient*
	* **plottingmode** = *1, 2, or 3, plot x, y, or z components of above properties*
8.  calibrate
	* **file_input**: *Logical (default, .false.), is this a PML calibration run?*
	* **qlist_file**:  *str, file with a list of q vectors*
	* **slist_file**:  *str, file with a list of sigmamax values* 
	* **Llist_file**:  *str, files with a list of LPML values*
	* **Lpoint**:  *int (default: 1), which line of Llist_file to read
	* **spoint**:  *int (default: 1), which line of slist_file to read 
	* **qpoint**:  *int (default: 1), which line of qlist_file to read
